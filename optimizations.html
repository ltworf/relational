<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta name="description" content="Relational : Educational tool for relational algebra">
    <link rel="stylesheet" type="text/css" media="screen" href="stylesheets/stylesheet.css">
    <title>Relational</title>
  </head>

  <body>
    <!-- HEADER -->
    <div id="header_wrap" class="outer">
        <header class="inner">
          <a id="forkme_banner" href="https://github.com/ltworf/relational">View on GitHub</a>
          <a id="donate_banner" href="https://liberapay.com/ltworf">Donate</a>

          <h1 id="project_title"><a href="index.html">Relational</a></h1>
          <h2 id="project_tagline">Educational tool for relational algebra</h2>

            <section id="download">
              <a href="download.html">Downloads</a> |
              <a href="screnshots.html">Screenshots</a> |
              <a href="allowed_expressions.html">Query language</a> |
              <a href="grammar.html">Grammar</a> |
              <a href="types.html">Types</a> |
              <a href="shortcuts.html">GUI</a> |
              <a href="optimizations.html">Optimizations</a> |
            </section>
        </header>
    </div>

    <!-- MAIN CONTENT -->
    <div id="main_content_wrap" class="outer">
      <section id="main_content" class="inner">

<h2>Optimizations</h2>
<p>Relational provides a way to perform various optimizations on queries. It assumes that the query is correct.</p>

<p>An optimized query must return the same result of the original query. If you find a non working query please submit a bug report.</p>

<h3>General optimizations</h3>

<p>This class of optimizations does not need to have informations on the relations.</p>

<p>They will work on the expression tree and will modify it. The return value is the number of changes performed on the tree.</p>

<h4>Duplicated select</h4>
<table class="inline">
	<tr class="row0">
		<th class="col0"> Original </th><th class="col1"> Optimized </th>
	</tr>
	<tr class="row1">
		<td class="col0"> <em>σ <sub>k</sub> ( σ <sub>k</sub>(C))</em> </td><td class="col1"> <em>σ <sub>k</sub> (C)</em> </td>
	</tr>
	<tr class="row2">
		<td class="col0"> <em>σ <sub>k</sub> ( σ <sub>j</sub>(C))</em> </td><td class="col1"> <em>σ <sub>k ⋀ j</sub> (C)</em> </td>
	</tr>
</table>

<p>
The first one will work only if the expression is exactly the same. If the expression is equivalent but different (for example 3+2 is equivalent but different to 2+3) the 2nd kind of optimization will be used.
</p>

<h4>Down to unions subtractions intersections</h4>

<table class="inline">
	<tr class="row0">
		<th class="col0"> Original </th><th class="col1"> Optimized </th>
	</tr>
	<tr class="row1">
		<td class="col0"> <em>σ <sub>k</sub>  (a ᑌ b)</em> </td><td class="col1 rightalign">  <em>σ <sub>k</sub>(a) ᑌ σ <sub>k</sub>(b)</em> </td>
	</tr>
	<tr class="row2">
		<td class="col0"> <em>σ <sub>k</sub>  (a ᑎ b)</em> </td><td class="col1 rightalign">  <em>σ <sub>k</sub>(a) ᑎ σ <sub>k</sub>(b)</em> </td>
	</tr>
	<tr class="row3">
		<td class="col0"> <em>σ <sub>k</sub>  (a - b)</em> </td><td class="col1 rightalign">  <em>σ <sub>k</sub>(a) - σ <sub>k</sub>(b)</em> </td>
	</tr>
</table>

<p>It is an optimization because the selection is a O(n) operation while unions, subtractions or intersections are O(n<sup>2</sup>) operations. So pushing down the selection, we hope to reduce the size of the problem that the O(n<sup>2</sup>) operation will have to solve.</p>

<h4>Duplicated projection</h4>
<table class="inline">
	<tr class="row0">
		<th class="col0"> Original </th><th class="col1"> Optimized </th>
	</tr>
	<tr class="row1">
		<td class="col0"> <em>π <sub>i</sub> ( π <sub>j</sub> (R))</em> </td><td class="col1"> <em>π <sub>i</sub> (R)</em> </td>
	</tr>
</table>

<p>Doing two projection and in fact ignoring the result of the inner one is useless.</p>



<h4>Selection inside projection</h4>
<table class="inline">
	<tr class="row0">
		<th class="col0"> Original </th><th class="col1"> Optimized </th>
	</tr>
	<tr class="row1">
		<td class="col0"> <em>σ <sub>j</sub> (π <sub>k</sub> (R))</em> </td><td class="col1"> <em>π <sub>k</sub> (σ <sub>j</sub> (R))</em> </td>
	</tr>
</table>

<p>Performing the selection first, gives us hope that the projection operation (more complex) will be performed on a smaller set.<br /></p>


<h4>Swap rename select</h4>
<table class="inline">
	<tr class="row0">
		<th class="col0"> Original </th><th class="col1"> Optimized </th>
	</tr>
	<tr class="row1">
		<td class="col0"> <em>σ <sub>k</sub>(ρ <sub>j</sub>(R))</em> </td><td class="col1"> <em>ρ <sub>j</sub>(σ <sub>k</sub>(R))</em> </td>
	</tr>
</table>

<p>Renaming the attributes used in the selection, so the operation is still valid.<br />This is not really an heavy optimization, select is O(n) and rename is O(1), but it might make other optimizations possible as well, in the next step.
</p>



<h4>Futile renames</h4>
<table class="inline">
	<tr class="row0">
		<th class="col0"> Original </th><th class="col1"> Optimized </th>
	</tr>
	<tr class="row1">
		<td class="col0"> <em>ρ <sub>k➡k</sub>(R)</em> </td><td class="col1"> completely removes them. If some renames in the list are valid and some are not, the valid ones will be kept. </td>
	</tr>
</table>

<p>
This optimization is performed <strong>before</strong> performing <em>subsequent renames optimization</em>.
</p>



<h4Subsequent renames</h4>
<table class="inline">
	<tr class="row0">
		<th class="col0"> Original </th><th class="col1"> Optimized </th>
	</tr>
	<tr class="row1">
		<td class="col0"> <em>ρ <sub>k</sub>(R)(ρ <sub>j</sub>(R))</em> </td><td class="col1"> <em>ρ <sub>j,k</sub>(R)</em> </td>
	</tr>
</table>

<p>Using a single rename operation.<br />If j,k will contain things like <code>a➡b,b➡c</code>, they will be replaced with <code>a➡c</code>.<br />If j.k will contain things like <code>a➡b,b➡a</code>, they will be removed. If all the transformations are removed, the rename itself is removed.<br />
</p>



<h4>Futile union intersection subtraction</h4>

<p>
<em>A ⋈ A=A ⧑ A=A ⧒ A=A⧓A = A ᑌ A=A ᑎ A=A</em>.<br />So this optimization tries to locate unions, intersections and joins that share the same left and right operand, and replaces
them with the operand itself.<br />Also <em>A - A=∅</em>.<br />So it locates subtractions that share the same left and right operand and replaces them with <em>σ <sub>False</sub>(A)</em>. This is not as fast as replacing with an empty relation, but there is no such operator in relational algebra. Anyway Selection is O(n) and subtraction is O(n<sup>2</sup>), so we are saving time anyway.
</p>

<p>This function locates things like:</p>
<table class="inline">
	<tr class="row0">
		<th class="col0"> Original </th><th class="col1"> Optimized </th>
	</tr>
	<tr class="row1">
		<td class="col0"> <em>R ᑌ R</em> </td><td class="col1"> <em>R</em> </td>
	</tr>
	<tr class="row2">
		<td class="col0"> <em>R ᑎ R</em> </td><td class="col1"> <em>R</em> </td>
	</tr>
	<tr class="row3">
		<td class="col0"> <em>R - R</em> </td><td class="col1"> <em>σ <sub>False</sub> (R)</em> </td>
	</tr>
	<tr class="row4">
		<td class="col0"> <em>σ <sub>k</sub> (R) ᑌ R</em> </td><td class="col1"> <em>R</em> </td>
	</tr>
	<tr class="row5">
		<td class="col0"> <em>σ <sub>k</sub> (R) ᑎ R</em> </td><td class="col1"> <em>σ <sub>k</sub> (R)</em> </td>
	</tr>
	<tr class="row6">
		<td class="col0"> <em>σ <sub>k</sub> (R) - R</em> </td><td class="col1 rightalign">  <em>σ <sub>False</sub> (R)</em> </td>
	</tr>
	<tr class="row7">
		<td class="col0"> <em>R - σ <sub>k</sub> (R)</em> </td><td class="col1"> <em>σ <sub>¬k</sub> (R)</em> </td>
	</tr>
</table>

<p>
<code>R</code> doesn&#039;t have to be a relation. It can be a subtree too.
</p>



<h4>Swap union renames</h4>
<table class="inline">
	<tr class="row0">
		<th class="col0"> Original </th><th class="col1"> Optimized </th>
	</tr>
	<tr class="row1">
		<td class="col0"> <em>ρ <sub>a➡b</sub>(R) ᑌ ρ <sub>a➡b</sub>(Q)</em> </td><td class="col1"> <em>ρ <sub>a➡b</sub>(R ᑌ Q)</em> </td>
	</tr>
	<tr class="row2">
		<td class="col0"> <em>ρ <sub>a➡b</sub>(R) ᑎ ρ <sub>a➡b</sub>(Q)</em> </td><td class="col1"> <em>ρ <sub>a➡b</sub>(R ᑎ Q)</em> </td>
	</tr>
	<tr class="row3">
		<td class="col0"> <em>ρ <sub>a➡b</sub>(R) - ρ <sub>a➡b</sub>(Q)</em> </td><td class="col1"> <em>ρ <sub>a➡b</sub>(R - Q)</em> </td>
	</tr>
</table>

<p>
This will save the space taken by an extra relation needed to perform the 2nd rename.
</p>


<h4>Swap rename projection</h4>
<table class="inline">
	<tr class="row0">
		<th class="col0"> Original </th><th class="col1"> Optimized </th>
	</tr>
	<tr class="row1">
		<td class="col0"> <em>π <sub>k</sub>(ρ <sub>j</sub>(R))</em> </td><td class="col1"> <em>ρ <sub>j</sub>(π <sub>k</sub>(R))</em> </td>
	</tr>
</table>

<p>
This will let rename work on a hopefully smaller set and more important, will hopefully allow further optimizations.
</p>

<h4>Union and product</h4>
<table class="inline">
	<tr class="row0">
		<th class="col0"> Original </th><th class="col1"> Optimized </th>
	</tr>
	<tr class="row1">
		<td class="col0"> <em>A * B ∪ A * C</em> </td><td class="col1 rightalign">  <em>A * (B ∪ C)</em> </td>
	</tr>
</table>

<h4>Select union intersect subtract</h4>
<table class="inline">
	<tr class="row0">
		<th class="col0"> Original </th><th class="col1"> Optimized </th>
	</tr>
	<tr class="row1">
		<td class="col0"> <em>σ<sub>i</sub>(a) ᑌ σ<sub>q</sub>(a)</em> </td><td class="col1 rightalign">  <em>σ<sub>i ∨ q</sub>(a)</em> </td>
	</tr>
</table>

<p>This will allow the removal of an O(n<sup>2</sup>) operation like the union.</p>

<p>Both select must work on the same expression, the selects will be united into one, according to the following table:</p>

<table class="inline">
	<tr class="row0">
		<th class="col0"> original query </th><th class="col1"> resulting query </th>
	</tr>
	<tr class="row1">
		<td class="col0"> <em>σ<sub>i</sub>(a) ᑌ σ<sub>q</sub>(a)</em> </td><td class="col1"> <em>σ<sub>i ∨ q</sub>(a)</em> </td>
	</tr>
	<tr class="row2">
		<td class="col0"> <em>σ<sub>i</sub>(a) ᑎ σ<sub>q</sub>(a)</em> </td><td class="col1"> <em>σ<sub>i ∧ q</sub>(a)</em> </td>
	</tr>
	<tr class="row3">
		<td class="col0"> <em>σ<sub>i</sub>(a) - σ<sub>q</sub>(a)</em> </td><td class="col1"> <em>σ<sub>i ∧ ¬q</sub>(a)</em> </td>
	</tr>
</table>



<h3>Specific optimizations</h3>

<p>
This class of optimizations requires to have knowledge of the specific relations used (meaning that it will need to have access to real instances of the relations to work).
</p>

<h4>Projection and union</h4>
<table class="inline">
	<tr class="row0">
		<th class="col0"> Original </th><th class="col1"> Optimized </th>
	</tr>
	<tr class="row1"><td class="col0"><em>π a,b,c(A) ∪ π a,b,c(B)</em></td><td class="col1 rightalign"><em>π a,b,c(A ∪ B)</em></td></tr>
</table>

<p>If A and B are union compatible.</p>


<h4>Selection and product</h4>
<table class="inline">
	<tr class="row0">
		<th class="col0"> Original </th><th class="col1"> Optimized </th>
	</tr>
	<tr class="row1">
		<td class="col0"> <em>σ <sub>k</sub> (R*Q)</em> </td><td class="col1"> <em>σ <sub>l</sub> (σ <sub>j</sub> (R) * σ <sub>i</sub> (Q))</em> </td>
	</tr>
</table>

<p>Where j contains only attributes belonging to R, i contains attributes belonging to Q and l contains attributes belonging to both.</p>

<h4>Useless projection</h4>
<p>If a projection is done on all the attributes, it can be removed.</p>
      </section>
    </div>

    <!-- FOOTER  -->
    <div id="footer_wrap" class="outer">
      <footer class="inner">
        <p class="copyright">Relational maintained by <a href="http://ltworf.github.io/">Salvo 'LtWorf' Tomaselli</a></p>
        <p>Released under GPLv3. <a href="contribute.html">Contribute</a>.</p>
        <p>Last updated: March 22, 2023, 12:43 pm</p>
      </footer>
    </div>

  </body>
</html>
