
<p>The optimize module provides a way to perform various optimizations on queries. It assumes that the query is correct.</p>

<p>An optimized query should return the same result of the original query. If you find a non working query please submit a bug.</p>

<h3>Usage</h3>
<p>This code will perform all the available general optimizations on the expression, and will return the optimized expression.<br />
</p>
<pre><code>expression=optimizer.general_optimize(expression)</code></pre>

<h3>Working with the tree</h3>

<p>The expression tree allows to manipulate the expressions.</p>

<p>
To obtain the expression from the tree:
</p>
<pre><code>str(root)</code></pre>

<p>To generate the tree: (expression is  a valid string representing a relational expression)</p>
<pre><code>optimizer.tree(expression)</code></pre>

<p>Each node will have a name, that corresponds to its string representation. Also a kind variable, that specifies if the node is a relation or an operator.</p>

<p>Constants for kind.</p>

<pre><code>optimizer.RELATION=0
optimizer.UNARY=1
optimizer.BINARY=2
</code></pre>

<h4>Unary operator</h4>
<ul>
<li class="level1">name: string representation
</li>
<li class="level1">child: child expression
</li>
<li class="level1">props: parameters of the operation
</li>
</ul>



<h4>Binary operator</h4>
<ul>
<li class="level1">name: string representation
</li>
<li class="level1">left: left expression
</li>
<li class="level1">right: right expression
</li>
</ul>



<h4>Relation</h4>
<ul>
<li class="level1">name: string representation
</li>
</ul>


<h3>General optimizations</h3>

<p>This class of optimizations do not need to have informations on the relations.</p>

<p>The functions are implemented in the <code>optimizations.py</code> module.</p>

<p>They will work on the expression tree and will modify it. The return value is the number of changes performed on the tree.</p>



<h4>Duplicated select</h4>
<table class="inline">
	<tr class="row0">
		<th class="col0"> Original </th><th class="col1"> Optimized </th>
	</tr>
	<tr class="row1">
		<td class="col0"> <em>σ <sub>k</sub> ( σ <sub>k</sub>(C))</em> </td><td class="col1"> <em>σ <sub>k</sub> (C)</em> </td>
	</tr>
	<tr class="row2">
		<td class="col0"> <em>σ <sub>k</sub> ( σ <sub>j</sub>(C))</em> </td><td class="col1"> <em>σ <sub>k ⋀ j</sub> (C)</em> </td>
	</tr>
</table>

<p>
The first one will work only if the expression is exactly the same. If the expression is equivalent but different (for example 3+2 is equivalent but different to 2+3) the 2nd kind of optimization will be used.
</p>

<h4>Down to unions subtractions intersections</h4>

<p>
Yes the name is crazy.
</p>
<table class="inline">
	<tr class="row0">
		<th class="col0"> Original </th><th class="col1"> Optimized </th>
	</tr>
	<tr class="row1">
		<td class="col0"> <em>σ <sub>k</sub>  (a ᑌ b)</em> </td><td class="col1 rightalign">  <em>σ <sub>k</sub>(a) ᑌ σ <sub>k</sub>(b)</em> </td>
	</tr>
	<tr class="row2">
		<td class="col0"> <em>σ <sub>k</sub>  (a ᑎ b)</em> </td><td class="col1 rightalign">  <em>σ <sub>k</sub>(a) ᑎ σ <sub>k</sub>(b)</em> </td>
	</tr>
	<tr class="row3">
		<td class="col0"> <em>σ <sub>k</sub>  (a - b)</em> </td><td class="col1 rightalign">  <em>σ <sub>k</sub>(a) - σ <sub>k</sub>(b)</em> </td>
	</tr>
</table>

<p>It is an optimization because the selection is a O(n) operation while unions, subtractions or intersections are O(n<sup>2</sup>) operations. So pushing down the selection, we hope to reduce the size of the problem that the O(n<sup>2</sup>) operation will have to solve.</p>

<h4>Duplicated projection</h4>
<table class="inline">
	<tr class="row0">
		<th class="col0"> Original </th><th class="col1"> Optimized </th>
	</tr>
	<tr class="row1">
		<td class="col0"> <em>π <sub>i</sub> ( π <sub>j</sub> (R))</em> </td><td class="col1"> <em>π <sub>i</sub> (R)</em> </td>
	</tr>
</table>

<p>Doing two projection and in fact ignoring the result of the inner one isn&#039;t nice.</p>



<h4>Selection inside projection</h4>
<table class="inline">
	<tr class="row0">
		<th class="col0"> Original </th><th class="col1"> Optimized </th>
	</tr>
	<tr class="row1">
		<td class="col0"> <em>σ <sub>j</sub> (π <sub>k</sub> (R))</em> </td><td class="col1"> <em>π <sub>k</sub> (σ <sub>j</sub> (R))</em> </td>
	</tr>
</table>

<p>Performing the selection first, gives us hope that the projection operation (more complex) will be performed on a smaller set.<br /></p>


<h4>Swap rename select</h4>
<table class="inline">
	<tr class="row0">
		<th class="col0"> Original </th><th class="col1"> Optimized </th>
	</tr>
	<tr class="row1">
		<td class="col0"> <em>σ <sub>k</sub>(ρ <sub>j</sub>(R))</em> </td><td class="col1"> <em>ρ <sub>j</sub>(σ <sub>k</sub>(R))</em> </td>
	</tr>
</table>

<p>
renaming the attributes used in the selection, so the operation is still valid.<br />This is not really an heavy optimization, select is O(n) and rename is O(1), but it is an improvement and it might make other optimizations possible as well, in the next step.
</p>



<h4>Futile renames</h4>
<table class="inline">
	<tr class="row0">
		<th class="col0"> Original </th><th class="col1"> Optimized </th>
	</tr>
	<tr class="row1">
		<td class="col0"> <em>ρ <sub>k➡k</sub>(R)</em> </td><td class="col1"> completely removes them. If some renames in the list are valid and some are not, the valid ones will be kept. </td>
	</tr>
</table>

<p>
This optimization is performed <strong>before</strong> performing <em>subsequent renames optimization</em>.<br />
</p>



<h4Subsequent renames</h4>
<table class="inline">
	<tr class="row0">
		<th class="col0"> Original </th><th class="col1"> Optimized </th>
	</tr>
	<tr class="row1">
		<td class="col0"> <em>ρ <sub>k</sub>(R)(ρ <sub>j</sub>(R))</em> </td><td class="col1"> <em>ρ <sub>j,k</sub>(R)</em> </td>
	</tr>
</table>

<p>
hence using a single rename operation.<br />If j,k will contain things like <code>a➡b,b➡c</code>, they will be replaced with <code>a➡c</code>.<br />If j.k will contain things like <code>a➡b,b➡a</code>, they will be removed. If all the transformations are removed, the rename itself is removed.<br />
</p>



<h4>Futile union intersection subtraction</h4>

<p>
<em>A ᑌ A=A ᑎ A=A</em>.<br />So this optimization tries to locate unions and intersections that share the same left and right operand, and replaces 
them with the operand itself.<br />Also <em>A - A=∅</em>.<br />So it locates subtractions that share the same left and right operand and replaces them with <em>σ <sub>False</sub>(A)</em>. This is not as fast as replacing with an empty relation, but there is no such operator in relational algebra. Anyway Selection is O(n) and subtraction is O(n²), so we&#039;re saving time anyway.
</p>

<p>This function locates things like:</p>
<table class="inline">
	<tr class="row0">
		<th class="col0"> Original </th><th class="col1"> Optimized </th>
	</tr>
	<tr class="row1">
		<td class="col0"> <em>R ᑌ R</em> </td><td class="col1"> <em>R</em> </td>
	</tr>
	<tr class="row2">
		<td class="col0"> <em>R ᑎ R</em> </td><td class="col1"> <em>R</em> </td>
	</tr>
	<tr class="row3">
		<td class="col0"> <em>R - R</em> </td><td class="col1"> <em>σ <sub>False</sub> (R)</em> </td>
	</tr>
	<tr class="row4">
		<td class="col0"> <em>σ <sub>k</sub> (R) ᑌ R</em> </td><td class="col1"> <em>R</em> </td>
	</tr>
	<tr class="row5">
		<td class="col0"> <em>σ <sub>k</sub> (R) ᑎ R</em> </td><td class="col1"> <em>σ <sub>k</sub> (R)</em> </td>
	</tr>
	<tr class="row6">
		<td class="col0"> <em>σ <sub>k</sub> (R) - R</em> </td><td class="col1 rightalign">  <em>σ <sub>False</sub> (R)</em> </td>
	</tr>
	<tr class="row7">
		<td class="col0"> <em>R - σ <sub>k</sub> (R)</em> </td><td class="col1"> <em>σ <sub>¬k</sub> (R)</em> </td>
	</tr>
</table>

<p>
<code>R</code> doesn&#039;t have to be a relation. It can be a subtree too.
</p>



<h4>Swap union renames</h4>
<table class="inline">
	<tr class="row0">
		<th class="col0"> Original </th><th class="col1"> Optimized </th>
	</tr>
	<tr class="row1">
		<td class="col0"> <em>ρ <sub>a➡b</sub>(R) ᑌ ρ <sub>a➡b</sub>(Q)</em> </td><td class="col1"> <em>ρ <sub>a➡b</sub>(R ᑌ Q)</em> </td>
	</tr>
	<tr class="row2">
		<td class="col0"> <em>ρ <sub>a➡b</sub>(R) ᑎ ρ <sub>a➡b</sub>(Q)</em> </td><td class="col1"> <em>ρ <sub>a➡b</sub>(R ᑎ Q)</em> </td>
	</tr>
	<tr class="row3">
		<td class="col0"> <em>ρ <sub>a➡b</sub>(R) - ρ <sub>a➡b</sub>(Q)</em> </td><td class="col1"> <em>ρ <sub>a➡b</sub>(R - Q)</em> </td>
	</tr>
</table>

<p>
This will save the space taken by an extra relation needed to perform the 2nd rename.
</p>


<h4>Swap rename projection</h4>
<table class="inline">
	<tr class="row0">
		<th class="col0"> Original </th><th class="col1"> Optimized </th>
	</tr>
	<tr class="row1">
		<td class="col0"> <em>π <sub>k</sub>(ρ <sub>j</sub>(R))</em> </td><td class="col1"> <em>ρ <sub>j</sub>(π <sub>k</sub>(R))</em> </td>
	</tr>
</table>

<p>
This will let rename work on a hopefully smaller set and more important, will hopefully allow further optimizations.<br />Will also eliminate fields in the rename that are cutted in the projection. So the memory needed to perform the task will be reduced.<br />
</p>



<h4>Select union intersect subtract</h4>
<table class="inline">
	<tr class="row0">
		<th class="col0"> Original </th><th class="col1"> Optimized </th>
	</tr>
	<tr class="row1">
		<td class="col0"> <em>σ<sub>i</sub>(a) ᑌ σ<sub>q</sub>(a)</em> </td><td class="col1 rightalign">  <em>σ<sub>i ∨ q</sub>(a)</em> </td>
	</tr>
</table>

<p>This will allow the removal of an O(n²) operation like the union.</p>

<p>Both select must work on the same expression, the selects will be united into one, according to the following table:</p>

<table class="inline">
	<tr class="row0">
		<th class="col0"> original query </th><th class="col1"> resulting query </th>
	</tr>
	<tr class="row1">
		<td class="col0"> <em>σ<sub>i</sub>(a) ᑌ σ<sub>q</sub>(a)</em> </td><td class="col1"> <em>σ<sub>i ∨ q</sub>(a)</em> </td>
	</tr>
	<tr class="row2">
		<td class="col0"> <em>σ<sub>i</sub>(a) ᑎ σ<sub>q</sub>(a)</em> </td><td class="col1"> <em>σ<sub>i ∧ q</sub>(a)</em> </td>
	</tr>
	<tr class="row3">
		<td class="col0"> <em>σ<sub>i</sub>(a) - σ<sub>q</sub>(a)</em> </td><td class="col1"> <em>σ<sub>i ∧ ¬q</sub>(a)</em> </td>
	</tr>
</table>



<h3>Specific optimizations</h3>

<p>
This class of optimizations requires to have knowledge of the specific relations used (meaning that it will need to have access to real instances of the relations to work).
</p>



<h4>Selection and product</h4>
<table class="inline">
	<tr class="row0">
		<th class="col0"> Original </th><th class="col1"> Optimized </th>
	</tr>
	<tr class="row1">
		<td class="col0"> <em>σ <sub>k</sub> (R*Q)</em> </td><td class="col1"> <em>σ <sub>l</sub> (σ <sub>j</sub> (R) * σ <sub>i</sub> (Q))</em> </td>
	</tr>
</table>

<p>Where j contains only attributes belonging to R, i contains attributes belonging to Q and l contains attributes belonging to both.</p>

